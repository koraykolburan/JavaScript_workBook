<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>JavaScript from Essentials to Advanced</title>
     <link rel="stylesheet" href="/css/style2.css">
</head>
<body>
     <header>
          <h1>JavaScript from Essentials to Advanced</h1>
     </header>
     <nav>
          <div class="first-nav">
               <h2>General Syntax</h2>
               <ul>
                    <li><a href="#primitive-data">Primitive Data</a></li>
                    <li><a href="#">Variables</a></li>
                    <li><a href="#">Functions</a></li>
                    <li><a href="#">IF Statements</a></li>
                    <li><a href="#">For Loop...</a></li>
               </ul>
          </div>
          <div class="second-nav">
               <h2>Advanced Topics</h2>
               <ul>
                    <li><a href="#">Prototype</a></li>
                    <li><a href="#">Scoping</a></li>
                    <li><a href="#">Window Object</a></li>
                    <li><a href="#">Document Object</a></li>
               </ul>
          </div>
       
     </nav>
     <main>
          <div class="wrapper">
               <section class="main-content1">
               <h2>Objects</h2>
               <p>Complexity is based on simplicity which is objects.</p>
               <p>Your program can only contain <strong>Nouns,</strong> <strong>Adjectives</strong> and  <strong>Verbs.</strong></p>
               <ul>
                    <li><b>Nouns</b> are descriptive.(-properties)</li>
                    <li><b>Adjectives</b> are descriptive.</li>
                    <li><b>Verbs</b> are descriptive.</li>
               </ul>
               <hr>
               <h3>Nouns</h3>
               <p>
                    - We have the <b>nouns</b>such as the width, height, color and weight. <br>
                    <h4>Properties</h4>
                    <code>
                         { <br>
                              &nbsp;    width: 25, <br>
                              &nbsp;    height: 27, <br>
                              &nbsp;    color: red, <br>
                              &nbsp;    weight:5, <br>
                              &nbsp;    eat: function(){ "Eat the apple."; }, <br>
                              &nbsp;    throw: function(){ "Throw the apple away."; }, <br>
                              &nbsp;    } 
                         <br>
                    </code> <br>
                    ! These are <b>nouns,</b> but they are <u>not good enough</u> to describe the entire object. 
               </p>
               <hr>
               <h3>Adjectives</h3>
               <p>
                    That's why we also need the <b>adjectives</b> as well. <br> 
                    Such as the string: <i>red.</i> <br>
               </p>
               <hr>
               <h3>Verbs</h3>
               <p>
                    Next, we need <strong>verbs</strong> all performing action which is a <strong>function</strong>. <br> 
                    <code>
                         &nbsp;    eat: function(){ "Eat the apple."; }, <br>
                         &nbsp;    throw: function(){ "Throw the apple away."; }, <br>
                    </code> <br>

               </p>
               <hr>
               <h3>Method</h3>
               <p>
                    - When a function is <u>within</u> an object it's still function. <br>
                    But we give it a different name: we call it a <b>Method.</b> <br>
                    <code>
                         { <br>
                              &nbsp;    width: 25, <br>
                              &nbsp;    height: 27, <br>
                              &nbsp;    color: red, <br>
                              &nbsp;    weight:5, <br>
                              <span id="separate">eat: function(){ "Eat the apple."; },</span> <br>
                              <span id="separate">throw: function(){ "Throw the apple away."; },</span> <br>
               &nbsp;    } 
                         <br>
                    </code> <br>
                    When we say a method, it simply means a function that is contained within an object.
                    <hr>
                    <b>Objects</b> are so important because they allow you to group information together that relate to certain aspects of your program. { ... }  
               </p>
               <hr>
               <h3>Object Oriented Programming</h3>
               <h4>Example:</h4>
               <p>
                    Take at your computer, take a look <br> 
                    <span id="code-block">{ the width, the height, the color, the KeyboardSize, the trackPadType }</span> so on and so forth.. <br>
                    And then, look at what you can do with the computer(functions-verbs). <br>
                    <span id="code-block">
                         { <br>
                              typeText: function(){ ... }, <br>
                              watchVideos: function(){ ... }, <br>
                         } <br>
                    </span>
               </p>
               <hr>
               <h3>Embedded Objects</h3>
               <h4>Example:</h4>
               <p>
                    Objects do contain objects. <br>
                    For example: your PC has camera, a screen, a keyboard, a trackpad.. <br>
                    Each of which their own nouns and verbs associated with each component in your PC. <br>
                    Objects nests hierarchially. For instance: The sub objects and The main parent objects. <br>
                    <span id="code-block">{ the width, the height, the color, the KeyboardSize, the trackPadType, typeText: function(){ ... }, watchVideos: function(){ ... }, keyboard: { language: "en-US", functional: true}, }</span>

               </p> 
               </section>
               <section class="main-content2">
               <section>
                    <h3>API - Application Programming Interface</h3>
                    <p>
                         An API is simply a collection of functions and also properties as well. <br>
                         There is a <b>Window {}</b> object in JavaScript that has many functions which are <b>Methods.</b> <br>
                         These were set up by Just In Time JavaScript Compiler. <br>
                    </p>
               </section>
               <section>
                    <h4>API's inside of API's</h4> 
                    <p>
                         for example: <b>jQuery.</b> <br>
                         jQuery attaches on to the Window object, that's why jQuery is an API. <br>
                         It has its own collection of functions and properties. <br>
                         That means jQuery needs the JavaScript API to define its own API. <br>
                         So jQuery is using those native API that come with JavaScript. <br>
                         The Native predefined functions and then its using those its own functions and creating its own style. <br>
                         You can call it an <b>Embedded API</b> that's what <b>libraries</b> are.
                    </p>
               </section>
               <hr>
               <section>
                    <h2 id="primitive-data">Primitive Data</h2>
                    <h3>JavaScript String</h3>
                         <p>
                              Strings are for storing text and they are written with quotes. <br>
                              <span id="code-block">
                                   let carName1 = "BMW X1"; <br>
                         &nbsp;    let carName2 = 'WV Tiguan';
                              </span> <br>
                              ! If there are no <span id="separate">QUOTATION MARKS,</span> these are not a <span id="separate">STRING.</span>
                         </p>
                    <h4>Template Strings</h4>
                         <p>
                              With back-ticks, you can use both single and double quotes inside a string like: <br>
                              <span id="code-block">
                                   let text = `That's the "real" answer for everything in life!`;
                              </span>
                         </p>
                         <hr>
                    <h4>Two Types of Numbers</h4>
                    <p>
                         <b>Integers:</b> 100, 200, 1, 2... <br>
                         <b>Floating Point Numbers:</b> 100.256, 1.1...
                    </p>
                    <hr>
                    <h4>Boolean</h4>
                    <p>
                         If something is not Boolean it sinks. <br>
                         Floating or sinking.. <br>
                         Negative or positive.. <br>
                         True or False..  <br>
                         It is like light switch.. On / Off <br>
                         Yes or No.. <br>
                         - When you have just the word <i>true</i> or <i>false</i> without the quoation marks, you are defining a Boolean. <br>
                    </p>
                    <hr>
                    <h4>Null & Undefined</h4>
                    <p>
                         <b>Null</b> = EMPTY. It does not have anything. <br>
                         <b>Undefined</b> = EMPTY. It does not have anything. <br>
                    </p>
                    <hr>
                    <h4>NaN</h4>
                    <p>
                         NaN = Not A Number. <br>
                         - If you wanted to check to see if a variable or a part of program has a number stored within it and that say <b>NaN:</b> Not A Number. <br>
                         Thus, you know not to use this variable all this value in Mathematical Expression for example.
                    </p>
               </section>
               </section>
          </div>
          <div class="wrapper">
               <section class="main-content3">
                    <h2>Variables, Constants & Assignment</h2>
                    <p>
                         Let's creating a variable. <br>
                         <span id="code-block">let</span> when you do that, you're creating a <b>BOX</b>. <br>
                         And a box needs a name. And this is not a string. It's actually defined as a symbol. <br>
                         It's a memory address. <br>
                         "=" equal sign is the assignment operator. <br>
                         let name = "John"; <br> 
                         <br>
                         Also we can create a box waiting for a value to be STORED. <br>
                         let blank; (it will return 'Undefined') <br>
                    </p>
                    <h3>Constant</h3>
                    <p>
                         <span id="code-block">Const</span> is constant throughout the lifetime of the execution of the program. <br>
                         Which you've defined a constant in your program is executing the constant always stays the same.
                    </p>
                    <hr>

                    <h2>Arithmetic Operator's & BODMAS</h2>
                    <p>
                         An Operator is a defined function function for the language. It's a function defined in the JIT Compiler. <br>
                         The JIT Compiler it's actually got these operators pre-defined ready to be executed in memory. It's a pre-defined subroutine. <br>
                    </p>
                    <h2>BODMAS</h2>
                    <p>
                         - There is a Operator Precedence. (execution first and later..)
                         <span id="code-block">
                              5 + 2 * 3; &nbsp;     =11 <br>
                         </span>
                         <span id="separate">
                              <b>B()</b> is Parantheses / Brackets. <br>
                              <b>pOwers()</b> is FUNCTION calls. <br>
                              <b>DM</b> is Division and Multiplication.( / and * ) <br>
                              <b>AS</b> is Addition and Subtraction. ( + and - ) <br>
                         </span>
                         <br>
                         <span id="code-block">
                              Math.pow(2,4) / 2 + 1 - 5 + ( 2 * 12 ); <br>
                              &nbsp;     = 28 <br>
                              <br>
                              Math.pow(12,2); <br>
                              &nbsp;     = 144 <br>
                         </span>
                         <br>
                              <b>% is Remainder of the Divison.</b> It's also called Modulus Divison. <br>
                              <span id="code-block">
                              9 % 5; <br>
                              &nbsp; = 4
                         </span>
                    </p>
               </section>
               <section class="main-content4">
                    <h2>Assignment Operators</h2>
                    <p>
                         <span id="code-block">
                                   let number = 20; <br>
                              &nbsp; number += 30; > 50<br>
                              &nbsp; number -= 30; > 20<br>
                              &nbsp; number *= 2; > 40 <br>
                              &nbsp; number /= 4; > 10<br>
                              &nbsp; number %= 4; > 2<br>
                         </span>
                         <br>
                         <span id="separate">
                              Double Asterisk:
                              &nbsp; number **= 4; > 16<br>
                              &nbsp; like Math.pow(2,4); > 16 <br>
                         </span>
                         <strong>! '**' is the exponentiation operator and is the equivalent of Math.pow(x,y).</strong>
                    </p>
                    <hr>
                    <h2>Polymorphism</h2>
                    <p>
                         When we write on the console this: <span id="code-block">"John " + 12;</span> <br>
                         The output is gonna be like this: <span id="code-block">"John 12"</span>. <br>
                         Becase it's like playdough. It changes and adapts itself into different shapes that you push it into. <br>
                         It just changes and adapts to the environment that you throw at it. <br>
                         If there is a Boolean on the one side like: <span id="separate">true + "John"</span> <br>
                         It will convert the Boolean type into a string data type and combine them like: <span id="separate"> "trueJohn"</span>. <br>
                         <span id="code-block"> 
                              let name = "John "; <br>
                              &nbsp; name += "Johnny"; <br>
                              &nbsp; "Johny Johnny" <br>
                         </span>
                         It will convert the Null and Undefined into a string too like:
                         <span id="code-block">
                              null + "John"; <br>
                              "nullJohn" <br>
                              undefined + "John"; <br>
                              "undefinedJohn" <br>
                         </span>
                         It always convert it into a string. It changes to suit its environment.
                    </p>
               </section>
          </div>
          <div class="wrapper">
               <section class="main-content5">
                    <h2>Functions or subroutines</h2>
                    <p>
                         <span id="separate">
                              function name ( parameter1, parameter2, ... ) { <br>
                              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instructions...      <br>
                              &nbsp; }                 <br>
                         </span>
                         <br>
                         ☉ Parameters are just variables. <br>
                         ☉ The variables that can have values assigned to them when we execute our instructions. <br>
                         ☉ And you have curly brackets. In between those brackets you have your set of instructions.
                         ☉ And then you can return instructions something.
                         <br>
                         <br>
                         <span id="code-block">
                              function makeBlackTea ( blackTea, water, lemon ) { <br>
                                   &nbsp;&nbsp;&nbsp;&nbsp; let instructions = "Boil water,";  <br>
                                   
                                   &nbsp;&nbsp;&nbsp;&nbsp; instructions += " pour into tea pot,"; <br>

                                   &nbsp;&nbsp;&nbsp;&nbsp; instructions += " add black tea leaves,"; <br>

                                   &nbsp;&nbsp;&nbsp;&nbsp; instructions += " wait 13 Mins."; <br>
                                   
                                   &nbsp;&nbsp;&nbsp;&nbsp; instructions += " After that, pour " + blackTea + "% blackTea into a tea cup "; <br>
                                   
                                   &nbsp;&nbsp;&nbsp;&nbsp; instructions += "and add " + water + " % water."; <br>
                                   
                                   &nbsp;&nbsp;&nbsp;&nbsp; instructions += " Finally, put " + lemon + " slices lemons."; <br>

                                   &nbsp;&nbsp;&nbsp;&nbsp; return instructions; <br>
                              &nbsp; } <br>
                         </span>
                         ! It's not actually being executed untill you want to make a cup of coffee. <br>
                         So for example: <span id="code-block">makeBlackTea ( 30, 70 , 2 );</span> <br>
                         <br>
                         Executing or Calling the Function: <br>
                         <span id="separate">
                              name of function ( argument1, arguement2, ); <br>
                         </span>
                         The arguments of values and parameters are the empty boxes of variables waiting to store the data. <br>
                         And then we can use this data in the execution.
                    </p>
               </section>
          </div>
          <div class="wrapper">
               <section class="main-content6">
                    <h2>Object & Arrays</h2>
                    <h3>Objects</h3>
                    <p>
                         Objects are obvious for what they are. You can identify directly: car, pc, phone... <br>
                         <i>'Curly Brackets {}'</i> <br>
                              <span id="code-block">
                                   {    <br>
                                        &nbsp;<u>key:</u> <u>"value"</u> >>> key and value pair is called <b>PROPERTY.</b><br>
                                        &nbsp; color: "grey", <br>
                                        &nbsp; speed: "220", <br>
                                        &nbsp; maker: "WV" <br>
                                        <br>
                                        &nbsp;<u>Methods:</u> <u>"instructions</u> <br>
                                        &nbsp; startEngine: function() { ... }" <br>
                                        &nbsp; stopEngine: function() { ... }" <br>
                              &nbsp;} <br>
                              </span>
                    </p>
                    <h3>Arrays</h3>
                    <p>
                         <b>Arrays</b> are list objects. For instance: a shopping list, a list of car names.. <br>
                         It's a list, it's iterable. <br>
                         <i>'Square Brackets []'</i> <br>
                         <b>Array</b> is an OBJECT. BUT it's a TYPE of OBJECT. <br>
                         It has elements that make up the complete object. <br>
                         For instance: A Shopping List; <br>
                         <span id="code-block">
                              [ <br>
                              &nbsp; "Banana", <br>
                              &nbsp; "Broccoli", <br>
                              &nbsp; "Avocado", <br>
                         &nbsp;] <br>
                         </span>
                         It's not necessary to define <u>key.</u> We need to define only <u>values.</u> <br>

                    </p>
                    <hr>
                    <h2>Embedded Objects & Arrays</h2>
                    <span id="code-block">
                         let car = { <br>
                              make: "WV", <br>
                              speed: 200, <br>
                                   engine: {   <br>
                                        size: 1.0, <br>
                                        make: "Mercedes", <br>
                                        fuel: "TSI", <br>
                                        Cylinders: [ { maker: "Mercedes" }, { maker: "Mercedes" }, { maker: "Mercedes2" } ] <br>
                                        } <br>
                              drive: function () { <br>
                                   return "drive"; <br>
                         }; <br>
                    };
                    </span> <br>

                    There is a hierarchy. <br>
                    <b>To sum up:</b> Objects can contain Objects or Arrays or both at the same time. <br>
                    And, Arrays can contain Array or Objects or both at the same time. <br>
                    <br>
                    Also, Objects and Arrays can contain FUNCTIONS except one thing; <br>
                    If Objects have function(methods) inside of itself, it needs to be take an <u>keyName:</u> <br>
                    On the other hand, if there is a function inside of the Array, it needs to be written without a function name which is a <u>keyName.</u>
               </section>
               <section class="main-content7">
                    <h2>Property Accessors - Member Access</h2>
                    <h3>-Dot Notation ' . '</h3>
                    <p>  
                         We need to use "DOT Notation" to access properties. <br>
                         We defined before this subject that; <br>
                         <span id="separate"> let car ={...}</span> <br> 
                         So we can access its properties in Console like these:<br>

                              <span id="separate">
                                   > car.make; <br>
                              </span>
                              <span id="code-block">
                                   &nbsp;< 'WV' (result)<br>
                              </span>
                              <hr>
                              <span id="separate">
                                   > car.engine.Cylinders; <br>
                              </span>
                              <span id="code-block">
                                   &nbsp;< (3) [{…}, {…}, {…}]  <br>
                                   &nbsp;&nbsp;0: {maker: 'Mercedes'} <br>
                                   &nbsp;&nbsp;1: {maker: 'Mercedes'} <br>
                                   &nbsp;&nbsp;2: {maker: 'Mercedes2'} <br>
                              </span>
                              <hr>
                              <span id="separate">
                                   > car.engine.make; <br>
                              </span>
                              <span id="code-block">
                                   &nbsp;< 'Mercedes'  <br>
                              </span>
                              <hr>
                              A method(function): <br>
                              <span id="separate">
                                   > car.startEngine(); <br>
                              </span>
                              <span id="code-block">
                                   &nbsp;< 'drive'  <br>
                              </span>
                    </p>
                    <hr>
                    <hr>
                    <hr>
                    <h3>-Computed Member Access & Bracket Notation '[ ... ]'</h3>
                    <p>
                         Whatever is in between the brackets and whatever is returned is treated as a memory pointer whether that be a number it could be a mathematical expression it could be a statement in JavaScript. <br>
                         <span id="separate">
                              > car.engine.Cylinders[2]; <br>
                         </span>
                         <span id="code-block">
                              &nbsp;< {maker: 'Mercedes2'}  <br>
                         </span>
                         <hr>
                         <span id="separate">
                              > car.engine.Cylinders[2].maker; <br>
                         </span>
                         <span id="code-block">
                              &nbsp;< 'Mercedes2'  <br>
                         </span>
                    </p>
                    <hr>
                    <h4>In Arrays:</h4>
                    <p>
                         <span id="code-block">
                              var Array = [ <br>
                                   "string", <br>
                                   100, <br>
                                   ["embed", 200], <br>
                                   { car: "ford" }, <br>
                                   function(){ return "drive"; } <br>
                                   ]; <br>
                         </span>
                         <br>
                         We need to write like this: <br> 
                         <span id="separate">Array[3]</span> the result is gonna be <span id="code-block">{car: 'ford'}</span> <br>
                         And If we write like this: <br>
                          <span id="separate">Array[3].car;</span> the result is gonna be <span id="code-block">'ford'</span> <br>
                          <br>
                         What about the <b>Function</b> inside of the Array? <br>
                         We need to add Parantheses in the end of accessing, like this: <br>
                         <span id="separate">Array[4]();</span> the result is gonna be <span id="code-block">'drive'</span>. <br>

                         Also, If we defined a item which is <span id="separate"> a = 10;</span>  <br>
                         And we can write this <span id="code-block">Array[ a - 2 - 5 ];</span> this is gonna be equals this <span id="separate">Array[3]</span> <br>
                         And the result of the two statement is gonna be the same like: <span id="code-block">{car: 'ford'}</span> <br>
                         ! It's computing the statement whatever is inside of those brackets. ! <br>
                         Don't forget! <span id="separate">car[ a ]</span> >>> inside these brackets is a <b>statement.</b> <br>
                         <br>
                         If we write like this: <span id="separate">car [ "make" ];</span> <br>
                         It's gonna be <span id="code-block">"WV"</span> (from our let = car {...} object). <br>
                         <br>
                         Also we can write like this: <span id="separate">car["engine"]["Cylinders"][2];</span> <br>
                         It's gonna be <span id="code-block">{maker: 'Mercedes2'}</span> (from our let = car {...} object). <br>
                         And <span id="separate">car["drive"]();</span> <br>
                         It's gonna be <span id="code-block">"drive"</span> (from our let = car {...} object). <br>
                         <hr>
                         Another things is: <br>
                         Let's create a variable has name "pointer" and define it to our "make" property which is inside of the "car" object: <br> 
                         <span id="separate"> let pointer = "make";</span> <br>
                         And then we can access like this: <br>
                         <span id="separate">car[ pointer ];</span> result is gonne be <span id="code-block">"WV"</span>. <br>
                         After that, Also it can be changed the value of the pointer variable. <br>
                         Like this: <span id="separate">pointer = "speed";</span>

                    </p>
               </section>
          </div>
          <div class="wrapper">
               <section class="main-content8">
                    <h2>Modifying Members of an Object</h2>
                         <ol>
                              <li>Creating a new Key & a new Method within this object.</li>
                              <li>Deleting certain Numbers & Methods within this object.</li>
                         </ol>
                    <h2>Modifying Members of an Array</h2>
                         <ol>
                              <li>Brackets syntax is not very good for ARRAYS. Also you have to be very careful again with the bracket syntax.</li>
                              <li>Also, dot notation is not very good for ARRAYS too.</li>
                              <li>Pre-built Methods(we need to use these)</li>
                         </ol>
                         <p>
                              Arrays are supposed to be a NUMERABLE and that means COUNTABLE. <br>
                              Actual Javascript Language created this for us automatically when we create an array it attaches another object onto it. <br>
                              And it's called the <b>PROTOTYPE Object.</b> <br>
                              <span id="separate">[[Prototype]]: Array(0)</span> <br>
                              But it comes with all of these different methods and these methods allow us to ITERATE OVER VALUES. <br>
                              <b>These are pre-built methods:</b> <br>
                              <span id="separate">(at(), concat(), cosntructor(), copyWithin(), entries(), every(), fill(), filter(), find(), findIndex() ... )</span> <br>
                              It allows us to filter data or inside of it. <br>
                              It allows us to change and modify data in our Array. <br>

                         </p>
                         <hr>
                    <h2>Callable Objects - Functions</h2>
                    <p>Or First-Class Citizen. This means that functions are simply a value and are just another type of object.</p>
                    <ol>
                         <li>{ instructions... }</li>
                         <li>Functions are callable objects they are objects that contain a list of instructions that are to be executed when they are invoked.
                         </li>
                         <li>Callable objects can be contained inside of objects so callable Objects can be contained inside of callable objects and you can keep nesting your callable objects inside of one another.
                         </li>
                         <li>And wherever you can pass in, so you can assign an object to a variable or a constant or you could assign a object to a parameter.</li>
                         <li>You could in fact change that object for in fact a function.</li>
                         <li>In Embedded Functions: We give it a variable, a parameter that will STORE 'the string' to the nested function. Then it will DELETE that out of memory.</li>
                         <li><b>Defining(invoking) a Function as an ARGUMENT:</b> A) Create a Callable Object and we give it a SYMBOL NAME and a parameter. B) Then we return the parameter inside of the Callable object. C) After that, we invoke this Callable Object with its SYMBOL NAME + parantheses but with THE NEW ARGUMENTS in the parantheses. D) Then the Callable Object receives THE NEW ARGUMENTS and ASSIGN it to ITS PARAMETER which we give it before. E) And then it returned it.(Look for Line:184 on JS for this.) </li>
                    </ol>
                    <hr>
                    <h2>Memory Hoisting</h2>
                    <p>
                         <b>Hoist?</b> It means lift up like a crane. <br> 
                         Or, if you wanted to change the engine in your car then you need a hoist to hoist the engine out of the car, so you can put the new one in. <br>
                         <b>Memory?</b> Potentially symbol names that refer to values that are stored in the memory. <br>
                         And these symbol names reference some point to certain values that are in memory. <br>
                         <br>
                         JS takes the symbol name and it hoists then lifts them up. <br>
                    </p>
                    <ol>
                         <li>When a <b>variable</b> or a <b>constant</b> is defined before initialization, JS doesn't access it.</li>
                         <li>In <b>Function</b> it's different. As it is a Function of Callable Object its execution context will be hoisted(will be lifted up). </li>
                         <li>Also, in every execution context, { console.log(),let var = "variable"; .... } we can think of this script as an execution context.</li>
                         <li>We also have execution context as well Callable Object have the execution context. { return ".." }, these also have hoisting. If we try to call a symbol that doesn't exist we get an error.</li>
                    </ol>
                    <h3>To sum up;</h3>
                    <p>
                         So for <b>variables and constants</b> it hoist only the memory pointer and it's just pointing to a black piece of memory. <br>
                         And also when it comes to <b>functions,</b> if symbol name points to a callable object: it hoists that to the top. <br>
                         Lastly, each execution context has memory hoisting <b>within it,</b> when you execute it.
                    </p>
                    <hr>
                    <h2>Scope</h2>
                    <h3>SCOPE of Objects</h3>
                    <ol>
                         <li>When we think about SCOPE we need to think about ACCESS. <b>SCOPE = ACCESS</b></li>
                         <li>There is ways in which you can access objects nested inside of other objects.</li>
                         <li>That is exactly what scopes are whether it be a Standard Object or a Callable Object, these are scopes they have their own access level. They have their own defined parameter if we will. <b>{ SCOPE = ACCESS }</b></li>
                         <li>And some <u>have greater access</u> and some have <u>more limited access</u> depending on where that callable object is and where that object resides.</li>
                         <li>We need to know how to access our objects individually one by one and then we can pull the data out. That is called <b>SCOPE. It has an access level.</b></li>
                    </ol>
                    <h3>Execution Stack(SCOPE of Functions or Callable Objects)</h3>
                    <ol> JS - Line 239:
                         <li>playThis() >>>> x = 25;</li>
                         <li>add() >>>> first) y = 75; second) x + y;</li>
                         <li>After all the execution is finished we have '100' returned.</li>
                         <li><b>GC - Garbage Collection:</b> Can any of the part of our application access those symbols after we have finished executing. NO, it can't. So now that we're finished with our execution it simply deletes those symbols out of memory.</li>
                    </ol>
                    <h3>Outer Execution Environment</h3>
                    <p>
                         And when we encapsulate this main thread with this temporary symbol table this temporary database that stores symbols it is called the outer execution environment that is this environment. <br>
                         It's a temporary environment in which our functions and those symbols which those functions have created just for the process of those functions. <br>
                         And that is this environment in which we're executing these lists of instructions here. <br>
                         And then it's clear it it's only a temporary space for execution to happen in our javascript program. <br>
                    </p>
                    <h3>To sum up:</h3>
                    <p>
                         So functions are callable objects callable objects have scope just like regular objects and you can have objects embedded in objects. <br> 
                         But callable objects are special in the fact that we have these temporary symbols table and the language feature is called a closure where any sort of symbol that is created inside of our execution stack as long as there is another callable object in there still in the execution stack. <br>
                         It keeps the symbol it and closes everything together and it keeps those symbols whilst we are executing all those instructions on the execution stack or the main thread. <br> 
                         Then once all of it's been executed it returns the final values and it does all of its operations. <br>
                         It then clears out the symbols that we can no longer reference in our program was we've executed these instructions we've done what we need to do with these instructions these instructions get thrown in bin. <br> 
                         Our instructions are in the bin and now we get garbage collection as well that deletes out these symbols so we're not wasting memory. <br> 
                         And that is also garbage collection and garbage collection is a big part of memory management so that we don't end up filling up all of the user's RAM and crushing the browser and being very very inefficient in storage. <br>
                         And javascript manages that automatically for you.
                    </p>
                    <hr>
                    <h2>GLOBAL SCOPE</h2>
                    <ol>
                         <li>The highest scope = global scope</li>
                    <li>Within a function, scope is different because functions have their on scopes nested within. If a function finds a variable (that it looking for) inside of itself, it returns it and stops the finding. </li>
                    <li>Each one of their braces has its own <b>SCOPE.</b></li>
                    <li>We have to be careful that using GLOBAL OBJECT. Because it can be changed inside of another functions as defining. If we want to change a GLOBAL CONSTANT or GLOBAL VARIABLE,  then that's perfectly fine or even a global subroutine. </li>
                    <li>If we want to create something within in the scope, we need to say <b>let engine = 'New String'. or const</b></li>
                    <li><b>Clobbering the Global Scope:</b>If we just type a SYMBOL NAME <b>without the declaration like: let or const</b> then we will INFER the GLOBAL!!! What we are doing create variable without the declaration names, it just creating a larger window object. And it's going to make it harder for the browser to really search through.</li>
                    </ol>
                    <hr>
                    <h2>'This' Context</h2>
                    <ul> Introduction;
                         <li>'this' word is a context based word, in other words it has context, it has reference.</li>
                         <li>If we were to say "look at this!" without the context while you simply wouldn't know what I was looking at. We need a context when we work with this!</li>
                         <li>When we open the our browser window, there is an environment that is established and that is the 'window' object. We create the windows object that contains all of the default properties and methods that make up the JavaScript API.</li>
                         <li>However we also have the 'this' keyword that is set up in memory and depending on where we use this keyword it will change and it will have different pointer.</li>
                    </ul>
                    <ol>
                         <li>First of all <b>'this'</b> by default points to the window object and then it can be changed.</li>
                         <li>If <b>'this'</b> keyword is found inside of <b>a property in an object</b> it just points to the <b>'window object'</b> to game, it doesn't changes context.(like let object1).</li>
                         <li>If we have an array and <b>array is an object</b> and the first key is zero: <b>'this' keyword.</b> Then we target this first element and we pull out the zero indexed item: <b>array1[0];</b> we get the <b>'window object'</b> again! </li>
                         <li><b>Callable Objects</b> allow us <b>to change</b> the <b>'this'</b> context! For example: We have a method within an object and this method returns whatever this is pointing to.</li>
                         <li>When we look at this on console: object1.method(); We can see that is no longer the 'window object'. <b>'this'</b> pointer is now going outside of the scope of the function by one.</li>
                         <li>And we also have the same for arrays. Because arrays are a type of object. We can log: array1[1]; output is gonna be this: (2) [Window, ƒ].</li>
                         <li>function global(){ return this; } this is pointing to <b>'window object'.</b> It is stepping out one into the <b>'window object'.</b> because this is a GLOBALLY SCOPED function right here.</li>
                    </ol>
                    <h3>Different ways to INVOKE the Functions</h3>
                    <ol>
                         <li><b>The Standard Function:</b> <span id="code-block">name();</span></li>
                         <li><b>The Object Invoke:</b> <span id="code-block">global.call( object1 );</span> We use the DOT SYNTAX to access members, properties and methods. It's just like we work with OBJECTS. So we can use the <b>call()</b> method. So this is proof that functions are treated as objects in JS. Then we can actually assign a value to this like: we are using object1 or array1, <b>global.call( object1 ); or global.call( array1 );</b> When we do that, it just like this: <span id="code-block">function global(){ return this = object1 or array1; }</span> So now, we've changed the context of 'this' which we can do with callable objects. </li>
                         <li> <span id="code-block">new global();</span> It adds a new this context. So this by default with the global context is going to be window, but <span id="separate">new</span> says 'no I want a new context, I literally want a blank object' like this: <span id="code-block">function global(){ return this = {} ; }</span> </li>
                    </ol>
                    <hr>
                    <h2>Constructors</h2>
                    <p>
                         Constructors in programming are in fact like construction workers. <br>
                         In JavaScript, we have constructors, this is the typical way that we create OBJECTS. <br>
                         Why do we need a construct to function? 
                    </p>
                    <ol>
                         <li>Create a Constructor Function with name and add in a capital letter to begin. The reason why we do this is because it helps us identify that this is a construct to function</li>
                         <li>Look at Line 304 JS.</li>
                    </ol>
                    <hr>
                    <h2>Prototypes</h2>
                    <p>They are just shared objects and allow us to share properties and methods across a range of objects.</p>
                    <ul>Look at the Line 339 JS.
                         <li>Prototypes are actually unique to javascript.</li>
                         <li>Prototypes are just shared objects. </li>
                         <li>There are objects that have properties and methods that can be accessed via a range of different objects and it's all down to how that object is constructed.</li>
                         <li>eat() and peelOff() methods are not unique to each of those pears objects. There's no point having a copy of the eat() and peelOff() methods for each object which is wasting memory. We're adding additional copies when we don't really need to do that. We don't need to <b>it on the instance level.</b></li>
                         <li><b>What is the instance level?</b> When you have a instance of something such as the constructor is the blueprint for an object and an instance is a copy of that object. So when we run that function, it returns an object that is an instance, it's a copy. And <b>on the instance level</b> it needs to be unique.</li>
                         <li><b>A Chain of Objects</b>Attaching a Prototype Object to our Constructor: we're actually defining a shared object. Everything that doesn't need to be duplicated so just eat() and peelOff(). They just stay in one place and we just have one copy.</li>
                         <li>So we have one copy of the eat() and peelOff() methods but when I access one of those objects such as Pears 1, 2 or 3 and I ask it for the eat() method, it will look at those objects, so what JS does is it automatically searches the <b>prototype chain.</b> And every one of those Pears objects is linked to that prototype object.</li>
                         <li><span id="separate">this</span> keyword in the prototype object it points back to the initial instance that invoked it.</li>
                    </ul>
                    <hr>
                    <h2>Constructors with Prototypes</h2>
                    <ol>
                         <li>If you want to know what in this context is you have to look at how that function was INVOKED!!!</li>
                         <li>The prototype object is attached to the 'callable object' that callable object that is the constructor. And when you construct an object from that constructor it is automatically linked to that callable object prototype object and that's it.</li>
                         <li>And the reason why that's really nice is because now you know that when we use this context in the prototype object it goes out to the instance level, so now We change the color property or we could change another property or add a New Property on to the instance level the unique level and change that object in particular which is really nice.</li>
                         <li>I can have a subroutine with <span id="separate">'this'</span> context and that this context will point to the instance level.</li>
                         <li><span id="code-block">The prototype</span> object and that <span id="separate">'this'</span> context allows you to go back up chain.
                         </li>
                    </ol>
               </section>
               <section class="main-content9">
                    <h2>Comparison & Conditional Execution</h2>
                    <ol>
                         <li><b>Double Equals</b> <span id="separate">"=="</span> Case Sensitive, Floating point Numbers, Primitive Values, Integers, <span id="code-block">'Undefined == Null': true;</span>is Polymorphism! One to be very careful of is NaN. <span id="separate">NaN == NaN; false.</span> So be very careful and never use NaN with Comparison!!! <span id="separate">10 == '10';</span> A string always takes precedence!!! Because strings can contain numbers and letters so you can turn an integer into a string. But you can't turn a string into an integer or a number!!! So to prevent this from happenning what we can do is use the TRIPLE EQUALS SIGN.</li>
                         <li><b>Triple Equals</b> <span id="separate">"==="</span> It will also checks the DATA TYPES as well.</li>
                         <li><b>Not Equals</b> <span id="separate">"!="</span> </li>
                    </ol>
               </section>
          </div>
     </main>

     
     <script src="/js/myapp.js"></script>
</body>
</html>